//!
//! # Count and Say (Medium) [String]
//! LeetCode Problem 38
//!

/// # `count_and_say`
/// Generates the nth term in the count-and-say sequence.
///
/// The count-and-say sequence is generated by counting the number of consecutive
/// digits in the previous term. For example, "1" becomes "11" (one 1),
/// "11" becomes "21" (two 1s), and so on.
///
/// ## Arguments
/// * `n` - The position in the sequence to generate (1 <= n <= 30)
///
/// ## Returns
/// * `String` - The nth term in the count-and-say sequence
pub fn count_and_say(n: i32) -> String {
    let mut current = String::from("1");

    if n == 1 {
        return current;
    }

    for _ in 1..n {
        let mut next = String::with_capacity(current.len() * 2);
        let mut count = 0;
        let mut last_char = None;

        for c in current.chars() {
            if let Some(lc) = last_char {
                if lc == c {
                    count += 1;
                } else {
                    next.push_str(&count.to_string());
                    next.push(lc);
                    count = 1;
                }
            } else {
                count = 1;
            }
            last_char = Some(c);
        }

        if let Some(lc) = last_char {
            next.push_str(&count.to_string());
            next.push(lc);
        }

        current = next;
    }

    current
}

fn main() {
    println!("LeetCode problem 38");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_count_and_say() {
        assert_eq!(count_and_say(1), "1");
        assert_eq!(count_and_say(2), "11");
        assert_eq!(count_and_say(3), "21");
        assert_eq!(count_and_say(4), "1211");
        assert_eq!(count_and_say(5), "111221");
    }
}
